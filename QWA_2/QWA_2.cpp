using namespace std;
#include <iostream>
#include <cstdlib>


int main()
{
    std::cout << "Hello World!\n";
}



//Вопросы без ответов
//Вопросы без ответов
//Определите значения переменных после выполнения действий.

//------------------------------------------------------- 1
#include <stdio.h>
struct man1
{
	char name[20];
	int  dd, mm, yy;
	char* zodiak;
	struct	man1* next;
}
A1 = { "Петров",1,10,1969,"Весы",NULL },
B1 = { "Сидоров",8,9,1958,"Дева",&A1 },
* p1 = &B1;
void F1() {
	char	c1, c2, c3, c4;
	c1 = A1.name[2];	c2 = B1.zodiak[3];
	c3 = p1->name[3];	c4 = p1->next->zodiak[1];
}
//------------------------------------------------------- 2
struct man2
{
	char name[20];
	char* zodiak;
	struct	man2* next;
} C2[3] = {
	{"Петров","Весы",NULL },
	{"Сидоров","Дева",&C2[0] },
	{"Иванов","Козерог",&C2[1] }
};
void F2() {
	char	c1, c2, c3, c4;
	c1 = C2[0].name[2];
	c2 = C2[1].zodiak[3];
	c3 = C2[2].next->name[3];
	c4 = C2[2].next->next->zodiak[1];
}
//------------------------------------------------------- 3
struct tree3
{
	int vv;
	struct	tree3* l, * r;
}
A3 = { 1,NULL,NULL },
B3 = { 2,NULL,NULL },
C3 = { 3, &A3, &B3 },
D3 = { 4, &C3, NULL },
* p3 = &D3;
void F3() {
	int	i1, i2, i3, i4;
	i1 = A3.vv;		i2 = D3.l->vv;
	i3 = p3->l->r->vv; i4 = p3->vv;
}
//------------------------------------------------------- 4
struct tree4
{
	int vv;
	struct	tree4* l, * r;
}
F[4] =
{ { 1,NULL,NULL },
 { 2,NULL,NULL },
 { 3, &F[0], &F[1] },
 { 4, &F[2], NULL } };
void F4() {
	int	i1, i2, i3, i4;
	i1 = F[0].vv;		i2 = F[3].l->vv;
	i3 = F[3].l->r->vv;	i4 = F[2].r->vv;
}
//------------------------------------------------------- 5
struct	list5
{
	int	vv;
	struct	list5* pred, * next;
};
extern	struct list5 C5, B5, A5;
struct	list5	A5 = { 1, &C5, &B5 },
	B5 = { 2, &A5, &C5 },
	C5 = { 3, &B5, &A5 },
	* p5 = &A5;
void F5() {
	int	i1, i2, i3, i4;
	i1 = A5.next->vv;	i2 = p5->next->next->vv;
	i3 = A5.pred->next->vv;	i4 = p5->pred->pred->pred->vv;
}
//------------------------------------------------------ 6
char* p6[] = { "Иванов","Петров","Сидоров",NULL };
void F6() {
	char	c1, c2, c3, c4;
	c1 = *p6[0];		c2 = *(p6[1] + 2);
	c3 = p6[2][3];		c4 = (*(p6 + 2))[1];
}
//------------------------------------------------------ 7
struct	dat7
{
	int	dd, mm, yy;
}
aa = { 17,7,1977 },
bb = { 22,7,1982 };
struct 	man7
{
	char name[20];
	struct dat7* pd;
	struct dat7 dd;
	char* zodiak;
}
A7 = { "Петров", &aa, { 1,10,1969 }, "Весы" },
B7 = { "Сидоров", &bb, { 8,9,1958 }, "Дева" },
* p7 = &B7;
void F7() {
	int	i1, i2, i3, i4;
	i1 = A7.dd.mm;		i2 = A7.pd->yy;
	i3 = p7->dd.dd;		i4 = p7->pd->yy;
}
//------------------------------------------------------ 8
struct	dat8
{
	int	dd, mm, yy;
};
struct 	man8
{
	char name[20];
	struct dat8 dd[3];
}
A8[2] = {
{"Петров", {{1,10,1969},{8,8,1988},{3,2,1978}}},
{"Иванов",{{8,12,1958},{12,3,1976},{3,12,1967}}}
};
void F8() {
	int	i1, i2, i3, i4;
	i1 = A8[0].dd[0].mm;	i2 = A8[1].dd[2].dd;
}
//------------------------------------------------------ 9
struct man9
{
	char name[20];
	char* zodiak;
	struct	man9* next;
}
A9 = { "Петров","Весы",NULL },
B9 = { "Сидоров","Дева",&A9 },
* p9[4] = { &B9, &A9, &A9, &B9 };
void F9() {
	char	c1, c2, c3, c4;
	c1 = p9[0]->name[2];		c2 = p9[2]->zodiak[3];
	c3 = p9[3]->next->name[3];	c4 = p9[0]->next->zodiak[1];
}

// Определить тип данных переменной из контекста ее описания
//------------------------------------------------------10
////функция без параметров, возвращающая в качестве результата символ
char   f(void);
//------------------------------------------------------11
// указатель на функцию, возвращающую в качестве результата указатель на символ (строку).
char* f(void);
//------------------------------------------------------12
//массив указателей на функции, возвращающих целое. 
int    (*p[5])(void);
//------------------------------------------------------13
// указатель на функцию, возвращающую в качестве результата указатель на функцию, которая ничего не возвращает. 
void   (*(*p)(void))(void);
//------------------------------------------------------14
//функция, возвращающая указатель на функцию, возвращающую целое
int    (*f(void))();
//------------------------------------------------------15
//Функция, возвращающая указатель на указатель на целое
char** f(void);
//------------------------------------------------------16
//массив указателей на символы
typedef char* PTR;
PTR     a[20];
//------------------------------------------------------17
//функция, возвращающая указатель на функцию
typedef void (*PTR)(void);
PTR     F(void);
//------------------------------------------------------18
//массив указателей на фукнции
typedef void (*PTR)(void);
PTR     F[20];
//------------------------------------------------------19
//функция, возвращающая указатель на структуру
struct list { ... };
list* F(list*);
//------------------------------------------------------20
//массив указателей на указатель на пустой тип void
void** p[20];
//------------------------------------------------------21
//указатель на функцию, возвращающую указатель на строку (символ). 
char* (*pf)(char*);
//------------------------------------------------------22
//функция, возвращающая целое
int F(char*, ...);
//------------------------------------------------------23
//функция, возвращающая указатель на указатель на строку (символ).
char** F(int);
//------------------------------------------------------24
//функция, возвращающая указатель на строку(символ).
typedef char* PTR;
PTR F(int);

